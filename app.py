# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ojdJg10PY_dXsN0Gh6f4GfMu4KEd43Jg
"""

# app.py
import streamlit as st
import pandas as pd
import numpy as np
import requests
import io
import json

st.set_page_config(page_title="Pruebas Psicotécnicas Online", layout="wide")

st.title("Evaluación rápida")

# --- Cargar mapping: desde GitHub RAW o por upload ---
st.sidebar.header("Carga de preguntas")
option = st.sidebar.selectbox("Fuente de preguntas", ["GitHub (raw)", "Subir archivo (JSON/CSV)"])
questions = None

if option == "GitHub (raw)":
    url = st.sidebar.text_input("URL raw de questions.json",
                                value="https://raw.githubusercontent.com/usuario/repositorio/main/questions.json")
    if st.sidebar.button("Cargar desde GitHub"):
        try:
            r = requests.get(url)
            r.raise_for_status()
            questions = r.json()
            st.success("Preguntas cargadas desde GitHub")
        except Exception as e:
            st.error(f"Error: {e}")
else:
    uploaded = st.sidebar.file_uploader("Sube questions.json o questions.csv", type=["json","csv"])
    if uploaded is not None:
        if uploaded.name.endswith(".json"):
            questions = json.load(uploaded)
        else:
            dfq = pd.read_csv(uploaded)
            # Asumimos csv con columnas: q, factor, text, optA_text, optA_score, optB_text, optB_score, optC_text, optC_score
            questions = []
            for _, r in dfq.iterrows():
                qobj = {"q": int(r.q), "factor": r.factor, "text": r.text, "options": [
                    {"key":"A","text": r.get("optA_text","A"), "score": int(r.get("optA_score",0))},
                    {"key":"B","text": r.get("optB_text","B"), "score": int(r.get("optB_score",1))},
                    {"key":"C","text": r.get("optC_text","C"), "score": int(r.get("optC_score",2))}
                ]}
                questions.append(qobj)
        st.success("Archivo cargado")

if not questions:
    st.info("Carga el fichero de preguntas para comenzar")
    st.stop()

# --- Mostrar formulario ---
st.write("## Instrucciones")
st.write("Conteste todas las preguntas. Al finalizar haga click en 'Enviar'.")

# usar form para agrupar envío
with st.form("quiz"):
    answers = {}
    for q in questions:
        # radio por pregunta con label = texto; las opciones ordenadas por 'options'
        opts = {f"{opt['key']}: {opt['text']}": opt['score'] for opt in q['options']}
        chosen = st.radio(f"{q['q']}. {q['text']}", list(opts.keys()), index=0, key=f"q{q['q']}")
        answers[q['q']] = opts[chosen]
    submit = st.form_submit_button("Enviar")

if submit:
    # calcular raw por factor
    factor_raw = {}
    factor_count = {}
    for q in questions:
        f = q['factor']
        factor_raw[f] = factor_raw.get(f,0) + answers[q['q']]
        factor_count[f] = factor_count.get(f,0) + 1

    # convertir raw a sten (1..10) linealmente
    factor_sten = {}
    for f in factor_raw:
        raw = factor_raw[f]
        minv = 0
        maxv = 2 * factor_count[f]  # asumiendo puntajes 0..2
        sten = int(round(1 + 9 * (raw - minv) / (maxv - minv)))
        factor_sten[f] = max(1, min(10, sten))

    st.subheader("Resultados por factor")
    df_res = pd.DataFrame([
        {"factor": f, "raw": factor_raw[f], "count": factor_count[f], "sten": factor_sten[f]}
        for f in sorted(factor_raw.keys())
    ])
    st.dataframe(df_res)

    # Guardar CSV de respuestas y resultados
    out_df = pd.DataFrame({
        "question": [q["q"] for q in questions],
        "factor": [q["factor"] for q in questions],
        "answer_score": [answers[q["q"]] for q in questions]
    })
    out_df.to_csv("last_responses.csv", index=False)
    st.download_button("Descargar respuestas (CSV)", data=out_df.to_csv(index=False), file_name="16pf_responses.csv")

    # Insertar interpretación (simple): si tienes interpretation.json úsalo para mostrar textos
    st.subheader("Interpretación (resumen)")
    # Ejemplo simple usando umbrales
    for f in sorted(factor_sten.keys()):
        s = factor_sten[f]
        if s <= 3:
            txt = "Rango bajo: " + " (texto interpretativo corto aquí)..."
        elif s >= 8:
            txt = "Rango alto: " + " (texto interpretativo corto aquí)..."
        else:
            txt = "Rango medio: " + " (texto interpretativo corto aquí)..."
        st.markdown(f"**Factor {f}** — Sten: {s} — {txt}")

    st.success("Fin de la evaluación")